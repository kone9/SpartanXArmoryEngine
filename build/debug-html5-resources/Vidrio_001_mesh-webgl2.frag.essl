#version 300 es
precision mediump float;
precision highp int;

const vec3 _345[3] = vec3[](vec3(1.0), vec3(0.0, 0.236836016178131103515625, 1.0), vec3(0.0, 0.236836016178131103515625, 1.0));
const float _359[3] = float[](0.063636370003223419189453125, 0.75454580783843994140625, 1.0);

in highp vec3 wnormal;
in highp vec3 bposition;
out highp vec4 fragColor[3];

highp float hash_f(highp vec3 co)
{
    return fract(sin(dot(co, vec3(12.98980045318603515625, 78.233001708984375, 52.82649993896484375)) * 24.3840007781982421875) * 43758.546875);
}

highp float voronoi_distance(highp vec3 a, highp vec3 b, int metric, highp float exponent)
{
    if (metric == 0)
    {
        return distance(a, b);
    }
    else
    {
        if (metric == 1)
        {
            return (abs(a.x - b.x) + abs(a.y - b.y)) + abs(a.z - b.z);
        }
        else
        {
            if (metric == 2)
            {
                return max(abs(a.x - b.x), max(abs(a.y - b.y), abs(a.z - b.z)));
            }
            else
            {
                if (metric == 3)
                {
                    return pow((pow(abs(a.x - b.x), exponent) + pow(abs(a.y - b.y), exponent)) + pow(abs(a.z - b.z), exponent), 1.0 / exponent);
                }
                else
                {
                    return 0.5;
                }
            }
        }
    }
}

highp vec3 tex_voronoi(highp vec3 coord, highp float r, int metric, int outp, highp float scale, highp float _exp)
{
    highp float randomness = clamp(r, 0.0, 1.0);
    highp vec3 scaledCoord = coord * scale;
    highp vec3 cellPosition = floor(scaledCoord);
    highp vec3 localPosition = scaledCoord - cellPosition;
    highp float minDistance = 8.0;
    highp vec3 targetOffset;
    highp vec3 targetPosition;
    for (int k = -1; k <= 1; k++)
    {
        for (int j = -1; j <= 1; j++)
        {
            for (int i = -1; i <= 1; i++)
            {
                highp vec3 cellOffset = vec3(float(i), float(j), float(k));
                highp vec3 pointPosition = cellOffset;
                if (randomness != 0.0)
                {
                    pointPosition += (vec3(hash_f(cellPosition + cellOffset), hash_f((cellPosition + cellOffset) + vec3(972.3699951171875)), hash_f((cellPosition + cellOffset) + vec3(342.480010986328125))) * randomness);
                }
                highp float distanceToPoint = voronoi_distance(pointPosition, localPosition, metric, _exp);
                if (distanceToPoint < minDistance)
                {
                    targetOffset = cellOffset;
                    minDistance = distanceToPoint;
                    targetPosition = pointPosition;
                }
            }
        }
    }
    if (outp == 0)
    {
        return vec3(minDistance);
    }
    else
    {
        if (outp == 1)
        {
            if (randomness == 0.0)
            {
                return vec3(hash_f(cellPosition + targetOffset), hash_f((cellPosition + targetOffset) + vec3(972.3699951171875)), hash_f((cellPosition + targetOffset) + vec3(342.480010986328125)));
            }
            return (targetPosition - targetOffset) / vec3(randomness);
        }
    }
    return (targetPosition + cellPosition) / vec3(scale);
}

highp vec2 octahedronWrap(highp vec2 v)
{
    return (vec2(1.0) - abs(v.yx)) * vec2((v.x >= 0.0) ? 1.0 : (-1.0), (v.y >= 0.0) ? 1.0 : (-1.0));
}

highp float packFloatInt16(highp float f, uint i)
{
    uint bitsInt = i << 12u;
    uint bitsFloat = uint(f * 4095.0);
    return float(bitsInt | bitsFloat);
}

highp float packFloat2(highp float f1, highp float f2)
{
    return floor(f1 * 255.0) + min(f2, 0.9900000095367431640625);
}

void main()
{
    highp vec3 n = normalize(wnormal);
    highp float VoronoiTexture_Distance_res = tex_voronoi(bposition, 1.0, 0, 0, 6.0, 0.5).x;
    highp float ColorRamp_fac = VoronoiTexture_Distance_res;
    int ColorRamp_i = 0 + int(ColorRamp_fac > 0.75454580783843994140625);
    highp vec3 ColorRamp_Color_res = mix(_345[ColorRamp_i], _345[ColorRamp_i + 1], vec3(max((ColorRamp_fac - _359[ColorRamp_i]) * (1.0 / (_359[ColorRamp_i + 1] - _359[ColorRamp_i])), 0.0)));
    highp vec3 basecol = ColorRamp_Color_res;
    highp float roughness = 0.0764710009098052978515625;
    highp float metallic = 0.0;
    highp float occlusion = 1.0;
    highp float specular = 0.5;
    highp vec3 emissionCol = vec3(0.0);
    n /= vec3((abs(n.x) + abs(n.y)) + abs(n.z));
    highp vec2 _408;
    if (n.z >= 0.0)
    {
        _408 = n.xy;
    }
    else
    {
        _408 = octahedronWrap(n.xy);
    }
    n = vec3(_408.x, _408.y, n.z);
    fragColor[0] = vec4(n.xy, roughness, packFloatInt16(metallic, 0u));
    fragColor[1] = vec4(basecol, packFloat2(occlusion, specular));
    fragColor[2] = vec4(emissionCol, 0.0);
}

